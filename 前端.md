***随便记录点问题***


### 1、Object.definepropertyte对象原型
### 2、Object.Prototypes对象原型
### 3、数组的操作
### 4、promise
### 5、apply call  bind
### 6、let const var
### 7、闭包
```
 让外部访问函数内部变量成为可能；
 	局部变量会常驻在内存中；
  	可以避免使用全局变量，防止全局变量污染；
  	会造成内存泄漏（有一块内存空间被长期占用，而不被释放）
```
### 8、深拷贝 浅拷贝
```
=赋值为浅拷贝，循环或递归赋值为深拷贝
```
### 9、arguments
```
类似数组，不是数组，可以获取实参的值
```
### 10、this指向

### 11、vue  父子件通信
```
父传子：父组件中数据已知，子组件数据未知子组件想要使用父组件的值
可以用过属性绑定的方式将父组件的值传递给子组件使用
在父组件中，以标签形式使用子组件的时候，可以通过属性绑定，为子组件传递数据，
父组件中需要书写的
在子组件中如果想用父组件的值，需要在子组件中定义props数组来接受
子传父：子组件给父组件传值，写this.$emit("a")
在父组件标签中写@a="a()" 事件 来接收
```
### 12、vuex 状态管理
```
stata
actions
mutations
getters
model
```
### 13、路由的监听
```
拦截器
router.beforeEach() 主要做一些鉴权
router.afterEach() 主要做一些鉴权
方式一
 beforeRouteEnter  beforeRouteUpdate  beforeRouteLeave
方式二
$route(to,from){
  console.log(to.path);
}

路由传参：pai rua me s => params  query  还有route路径加参数
```
参考：https://www.cnblogs.com/crazycode2/p/8727410.html
### 14、devserver为什么会失效
因为devserver是开发应用的，不是生产使用的
### 15、去除重复、排序

### 16、vue插槽
```
slot是父组件与子组件的通信方式，可以将父组件的内容显示在子组件当中。
```
### 17、promise捕获异常怎么执行
```
挂起
已成功
已完成
```
### 18、package.json、package-lock.json
### 19、ES6语法 let const => class
### 20、分页器的实现
### 21、vue路由的种类
```
Hash:      使用URL的hash值来作为路由。支持所有浏览器。
History:   以来HTML5 History API 和服务器配置。参考官网中HTML5 History模式
Abstract： 支持所有javascript运行模式。如果发现没有浏览器的API，路由会自动强制进入这个模式。
```
### 22、vue路由跳转有哪两种方式、特点
```
1. router-link
2.this.$router.push 跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面
3.this.$router.replace 跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)
4.this.$router.go(n) 向前或者向后跳转n个页面，n可为正整数或负整数
路由传递参数 params参数 query参数
```
https://www.cnblogs.com/dekevin/p/12347793.html
### post 与 get
```
```
### 24、Git
```
创建分支：git branch
切换+切换分支：git checkout
```

### 25、防抖

```
function debounce(func, wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);

        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait);
    }
}

```

### 26、节流

```
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }

```

### 27、cookies，sessionStorage 和 localStorage 的区别
```
cookie在浏览器和服务器间来回传递。
sessionStorage和localStorage不会
sessionStorage和localStorage的存储空间更大；
sessionStorage和localStorage有更多丰富易用的接口；
sessionStorage和localStorage各自独立的存储空间；
HTML5的离线存储
localStorage 长期存储数据，浏览器关闭后数据不丢失；
而sessionStorage数据在浏览器关闭后自动删除。
cookie和session的区别
① cookie数据存在客户的浏览器上，session数据存放在服务器端
② cookie不安全
③ session会在一定时间内保存在服务器端，访问增多，占用服务器性能。
④ 单个cookie保存的数据不超过4K

```
![avatar](/img/1.jpg)
https://www.cnblogs.com/yanggb/p/10675855.html
### 28、Vue?
```
　　Vue.js是一个构建数据驱动的Web界面的渐进式框架。Vue.js的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合，当与单文件组件和Vue生态系统支持的库结合使用时，Vue也完全能够为复杂的单页应用程序提供驱动。
```
### 29、Vue的双向绑定数据的原理
```
　　Vue实现数据双向绑定主要是：采用数据劫持结合“发布者 - 订阅者”模式的方式，通过 Object.defineProperty()来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应监听回调。
```
### 30、Vue如何去除URL中的#
```
　　vue-router默认使用hash模式，所以在路由加载的时候，项目中的URL会自带“#”。如果不想使用“#”,可以使用vue-router的另一种模式history
```
```
new Router({
　　mode: 'history', routes: [ ]
})
```
### 31、Vue生命周期的理解
```
　　Vue实例有一个完整的生命周期，生命周期也就是指一个实例从开始创建到销毁的这个过程。
　　beforeCreated()：在实例创建之间执行，数据未加载状态。
　　created()：在实例创建、数据加载后，能初始化数据，DOM渲染之前执行。
　　beforeMount()：虚拟DOM已创建完成，在数据渲染前最后一次更改数据。
　　mounted()：页面、数据渲染完成，真实DOM挂载完成。
　　beforeUpadate()：重新渲染之前触发。
　　updated()：数据已经更改完成，DOM也重新render完成，更改数据会陷入死循环。
　　beforeDestory()和destoryed()：前者是销毁前执行(实例仍然完全可用)，后者则是销毁后执行。
```
### 32、说一说单向数据流和双向数据绑定的优缺点
```
　　单向数据流：顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种action来维护对应的state。
　　双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时debug的难度。
```
### 33、vue-router路由实现
```
　　路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。
```
### 34、v-if和v-show区别
```
　　使用v-if的时候，如果值为false，那么页面将不会有这个html标签生成。
　　v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏。
```
### 35、$route和$router的区别
```
　　$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法。
　　$route为当前router跳转对象里面可以获取name、path、query、params等。
```
### 36、Vue组件data为什么必须是函数
```
　　因为JS本身的特性带来的，如果data是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将data作为一个函数返回一个对象，那么每一个实例的data属性都是独立的，不会相互影响了。
```
### 37、jQuery、Vue有什么不同
```
　　jQuery专注视图层，通过操作DOM去实现页面的一些逻辑渲染；Vue专注于数据层，通过数据的双向绑定，最终表现在DOM层面，减少了DOM操作。Vue使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发。
```
### 38.ajax与axios区别
```
ajax
传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。
```
```
axios
axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：
1.从浏览器中创建 XMLHttpRequest
2.支持 Promise API
3.客户端支持防止CSRF
4.提供了一些并发请求的接口（重要，方便了很多的操作）
5.从 node.js 创建 http 请求
6.拦截请求和响应
7.转换请求和响应数据
8.取消请求
9.自动转换JSON数据
```
### 39、CSRF跨站请求伪造
### 40、less和sass的相同之处
```
Less和Sass在语法上有些共性，比如下面这些：
1、混入(Mixins)——class中的class；
2、参数混入——可以传递参数的class，就像函数一样；
3、嵌套规则——Class中嵌套class，从而减少重复的代码；
4、运算——CSS中用上数学；
5、颜色功能——可以编辑颜色；
6、名字空间(namespace)——分组样式，从而可以被调用；
7、作用域——局部修改样式；
8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。
```
### 41、less和sass的区别
```
Less是基于JavaScript，是在客户端处理的。
Sass是基于Ruby的，是在服务器端处理的。
关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。
输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。
```
### 42、回调地狱

### 43、tcp属于哪一层（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 会话层-> 6 表示层-> 7 应用层(http)）

### 44、js运行机制
```
感觉讲的不错 https://www.jianshu.com/p/e06e86ef2595
```
### 45、css不可继承属性
```
1:不可继承的:display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、
bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、
page-bread-before、unicode-bidi
```
```
2:所有元素可继承：visibility和cursor。
```
```
3:内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction
```
```
终端块状元素可继承：text-indent和text-align
```
```
列表元素可继承：list-style、list-style-type、list-style-position、list-style-image
```


### 46、ssl

### 47、对称加密与非对称加密
```
对称加密: 加密和解密的秘钥使用的是同一个.
非对称加密: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。
```
### 48、http请求过程
HTTPS用的是对称加密还是非对称加密：讲的不错 https://www.cnblogs.com/imstudy/p/12015889.html
### 49、https 与 http关系

### 50、jwt

### 51、TLS：安全传输层协议，该协议有两层组成，TLS记录协议和TLS握手协议

### 52、SSL（secure socket layer）：是一个介于HTTP协议与TCP之间的可选层，安全套接字

### 53、TCP/IP（Transmission Control Protoco）传输控制协议/网际协议

### 54、跨域：后台配置同源策略（cros）、Nginx代理、Jsonp

### 55、正向代理反向代理区别
```
nginx主要实现反向代理，负载均衡
反向代理，不暴露资源，不知道请求的是哪台服务器，百度等公司部署网站的方式,保护内网安全
正向代理，暴露资源，例如直接访问谷歌，不能访问，需要一个跳板机，才能访问，VPN:正向代理
```
### 56、http响应返回200与304的区别？参考：https://blog.csdn.net/u012902406/article/details/81000955